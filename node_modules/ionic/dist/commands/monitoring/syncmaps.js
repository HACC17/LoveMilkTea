"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const path = require("path");
const chalk = require("chalk");
const cli_utils_1 = require("@ionic/cli-utils");
const command_1 = require("@ionic/cli-utils/lib/command");
const http_1 = require("@ionic/cli-utils/lib/http");
const http_2 = require("@ionic/cli-utils/lib/utils/http");
const fs_1 = require("@ionic/cli-utils/lib/utils/fs");
const guards_1 = require("@ionic/cli-utils/guards");
let MonitoringSyncSourcemapsCommand = class MonitoringSyncSourcemapsCommand extends command_1.Command {
    run(inputs, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const token = yield this.env.session.getUserToken();
            const appId = yield this.env.project.loadAppId();
            const { ConfigXml } = yield Promise.resolve().then(function () { return require('@ionic/cli-utils/lib/cordova/config'); });
            const conf = yield ConfigXml.load(this.env.project.directory);
            const cordovaInfo = yield conf.getProjectInfo();
            const appVersion = cordovaInfo.version;
            const commitHash = yield this.env.shell.run('git', ['rev-parse', 'HEAD'], { cwd: this.env.project.directory });
            const sourcemapsDir = path.join(this.env.project.directory, '.sourcemaps');
            let sourcemapsExist = yield fs_1.pathExists(sourcemapsDir);
            if (!sourcemapsExist) {
                this.env.log.info('No sourcemaps found, doing build...');
                yield this.doProdBuild();
                sourcemapsExist = yield fs_1.pathExists(sourcemapsDir);
                if (!sourcemapsExist) {
                    this.env.log.error('Unable to sync sourcemaps. Make sure you have @ionic/app-scripts version 2.1.4 or greater.');
                    return;
                }
            }
            else {
                const doNewBuild = yield this.env.prompt({
                    type: 'confirm',
                    name: 'isProd',
                    message: 'Do build before syncing?'
                });
                doNewBuild && (yield this.doProdBuild());
            }
            this.env.log.info(`Syncing SourceMaps for app version ${chalk.green(appVersion)} of ${chalk.green(cordovaInfo.id)}`);
            fs_1.readDir(sourcemapsDir).then(files => {
                const maps = files.filter(f => f.indexOf('.js.map') >= 0);
                Promise.all(maps.map(f => this.syncSourcemap(path.join(sourcemapsDir, f), appVersion, commitHash, appId, token)));
            });
        });
    }
    syncSourcemap(file, appVersion, commitHash, appId, token) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const req = this.env.client.make('POST', `/monitoring/${appId}/sourcemaps`)
                .set('Authorization', `Bearer ${token}`)
                .send({
                name: path.basename(file),
                version: appVersion,
                commit: commitHash
            });
            try {
                this.env.log.info(`Syncing ${chalk.green(file)}`);
                const res = yield this.env.client.do(req);
                if (res.meta.status !== 201) {
                    throw http_1.createFatalAPIFormat(req, res);
                }
                return this.uploadSourcemap(res, file);
            }
            catch (e) {
                if (guards_1.isSuperAgentError(e) && e.response.status === 409) {
                    this.env.log.error('Unable to sync map ${file}.');
                    this.env.tasks.fail();
                }
                else {
                    throw e;
                }
            }
        });
    }
    uploadSourcemap(res, file) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const r = res;
            const fileData = yield fs_1.fsReadFile(file, { encoding: 'utf8' });
            const sourcemapPost = r.data.sourcemap_post;
            http_2.createRequest('post', sourcemapPost.url)
                .buffer()
                .field(sourcemapPost.fields)
                .field('file', fileData)
                .on('progress', (event) => {
            })
                .end((err, res) => {
                if (err) {
                    this.env.log.error('Unable to upload sourcemap');
                    this.env.log.error(err);
                    return Promise.reject(err);
                }
                if (res.status !== 204) {
                    return Promise.reject(new Error(`Unexpected status code from AWS: ${res.status}`));
                }
                this.env.log.ok('Uploaded sourcemap');
                this.env.log.info('See the Error Monitoring docs for usage information and next steps: http://ionicframework.com/docs/pro/error-monitoring.html');
                Promise.resolve();
            });
        });
    }
    doProdBuild() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const isProd = yield this.env.prompt({
                type: 'confirm',
                name: 'isProd',
                message: 'Do full prod build?'
            });
            const { build } = yield Promise.resolve().then(function () { return require('@ionic/cli-utils/commands/build'); });
            return build(this.env, [], { _: [], prod: isProd });
        });
    }
};
MonitoringSyncSourcemapsCommand = tslib_1.__decorate([
    command_1.CommandMetadata({
        name: 'syncmaps',
        type: 'project',
        backends: [cli_utils_1.BACKEND_PRO],
        description: 'Sync Source Maps to Ionic Pro Error Monitoring service'
    })
], MonitoringSyncSourcemapsCommand);
exports.MonitoringSyncSourcemapsCommand = MonitoringSyncSourcemapsCommand;
